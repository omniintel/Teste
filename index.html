<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>OmniPlayer</title>
  <style>
    body { font-family: Arial, sans-serif; background: #111; color: white; padding: 20px; }
    #player-wrapper { width: 100%; height: 300px; background: #000; margin-bottom: 20px; position: relative; }
    #playerA, #playerB {
      position: absolute; width: 100%; height: 100%; top: 0; left: 0;
    }
    #sync-status { padding: 10px 20px; background: #00c3ff; color: white; border: none; border-radius: 8px; display: inline-block; }
    #playlist { display: flex; flex-wrap: wrap; gap: 10px; }
    .video-item { background: #222; padding: 10px; border-radius: 8px; width: 150px; cursor: pointer; transition: transform 0.2s; }
    .video-item:hover { transform: scale(1.03); }
    .thumbnail { width: 100%; border-radius: 4px; }
    .title { margin-top: 5px; font-size: 14px; color: #ddd; }
  </style>
</head>
<body>
  <h1>ðŸŽ® OmniPlayer</h1>
  <div id="player-wrapper">
    <div id="playerA"></div>
    <div id="playerB"></div>
  </div>
  <div id="sync-status">ðŸ”„ Verificando...</div>
  <div id="playlist"></div>

  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    const supabaseUrl = 'https://hgxuakniyncpbuvksiql.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhneHVha25peW5jcGJ1dmtzaXFsIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0ODcyNTA2MCwiZXhwIjoyMDY0MzAxMDYwfQ.PqFYkPC-87s3regeKRhfMsZi9t_at-LxQTP23RGOyEo';
    const playlistTable = 'videos';
    const syncTable = 'current_video';

    let playlist = [];
    let currentIndex = 0;
    let syncIdAtual = null;

    let playerA, playerB;
    let playerAReady = false;
    let playerBReady = false;
    let activePlayer = 'A';

    const crossfadeDuration = 10; // segundos
    const fadeIntervalMs = 200;
    let crossfadeInterval = null;

    // API Supabase
    async function fetchVideos() {
      const res = await fetch(`${supabaseUrl}/rest/v1/${playlistTable}?select=*`, {
        headers: { apikey: supabaseKey, Authorization: `Bearer ${supabaseKey}` }
      });
      const data = await res.json();
      return data.sort((a,b) => a.id - b.id);
    }

    async function updateSync(syncid, link) {
      await fetch(`${supabaseUrl}/rest/v1/${syncTable}?id=eq.1`, {
        method:'PATCH',
        headers: {apikey: supabaseKey, Authorization: `Bearer ${supabaseKey}`, 'Content-Type':'application/json'},
        body: JSON.stringify({syncid, sync: link})
      });
    }

    async function fetchSync() {
      const res = await fetch(`${supabaseUrl}/rest/v1/${syncTable}?id=eq.1&select=*`, {
        headers: {apikey: supabaseKey, Authorization: `Bearer ${supabaseKey}`}
      });
      const data = await res.json();
      return data.length>0 ? data[0] : null;
    }

    async function updateButtonState(value) {
      await fetch(`${supabaseUrl}/rest/v1/${syncTable}?id=eq.1`, {
        method:'PATCH',
        headers: {apikey: supabaseKey, Authorization: `Bearer ${supabaseKey}`, 'Content-Type':'application/json'},
        body: JSON.stringify({Button: value})
      });
    }

    async function checkButtonStatus() {
      const res = await fetch(`${supabaseUrl}/rest/v1/${syncTable}?id=eq.1&select=Button`, {
        headers: {apikey: supabaseKey, Authorization: `Bearer ${supabaseKey}`}
      });
      const data = await res.json();
      return data.length>0 ? data[0].Button : null;
    }

    // Interface
    async function updateSyncStatus() {
      const statusEl = document.getElementById('sync-status');
      const buttonStatus = await checkButtonStatus();
      if(buttonStatus === 1) {
        statusEl.innerText = 'ðŸ”„ Atualizando Playlist...';
        await updateButtonState(0);
        await reloadPlaylist();
      } else {
        statusEl.innerText = 'âœ… Playlist Atualizada';
      }
    }

    function renderPlaylist() {
      const container = document.getElementById('playlist');
      container.innerHTML = '';
      playlist.forEach((video, i) => {
        const item = document.createElement('div');
        item.className = 'video-item';

        const youtubeId = extractId(video.youtube_id);
        const thumbnail = document.createElement('img');
        thumbnail.src = `https://img.youtube.com/vi/${youtubeId}/default.jpg`;
        thumbnail.className = 'thumbnail';

        const title = document.createElement('div');
        title.className = 'title';
        title.innerText = `${i+1}. ${video.title || 'VÃ­deo'}`;

        item.onclick = () => setVideo(i);
        item.appendChild(thumbnail);
        item.appendChild(title);
        container.appendChild(item);
      });
    }

    function extractId(url) {
      if(!url) return '';
      if(url.includes('embed/')) return url.split('embed/')[1].split('?')[0];
      if(url.includes('v=')) return url.split('v=')[1].split('&')[0];
      return url; // id puro
    }

    // Youtube API
    function onYouTubeIframeAPIReady() {
      playerA = new YT.Player('playerA', {
        height:'100%', width:'100%', videoId:'',
        playerVars: {autoplay:0, controls:1},
        events: {
          onReady: () => { playerAReady = true; tryStartApp(); },
          onStateChange: onPlayerStateChange
        }
      });
      playerB = new YT.Player('playerB', {
        height:'100%', width:'100%', videoId:'',
        playerVars: {autoplay:0, controls:1},
        events: {
          onReady: () => { playerBReady = true; tryStartApp(); },
          onStateChange: onPlayerStateChange
        }
      });
    }

    function tryStartApp() {
      if(playerAReady && playerBReady) {
        loadApp();
      }
    }

    // Define vÃ­deo e inicia crossfade
    function setVideo(index) {
      if(!playlist[index]) return;
      clearInterval(crossfadeInterval);

      const nextVideo = playlist[index];
      const nextId = extractId(nextVideo.youtube_id);

      const inactivePlayer = activePlayer === 'A' ? playerB : playerA;
      const activePlayerObj = activePlayer === 'A' ? playerA : playerB;

      // Carrega no player inativo, volume 0, play
      inactivePlayer.loadVideoById(nextId);
      inactivePlayer.setVolume(0);
      inactivePlayer.playVideo();

      // Monitorar para iniciar crossfade
      function startFade() {
        crossfadeInterval = setInterval(() => {
          const timeActive = activePlayerObj.getCurrentTime();
          const duration = activePlayerObj.getDuration();
          if(!duration) return;

          const timeLeft = duration - timeActive;
          if(timeLeft <= crossfadeDuration) {
            const volInactive = Math.min(100, 100 * (crossfadeDuration - timeLeft)/crossfadeDuration);
            const volActive = Math.max(0, 100 * timeLeft/crossfadeDuration);
            activePlayerObj.setVolume(volActive);
            inactivePlayer.setVolume(volInactive);

            if(timeLeft <= 0) {
              currentIndex = index;
              syncIdAtual = nextVideo.id;
              updateSync(nextVideo.id, `https://www.youtube.com/embed/${nextId}`);
              activePlayer = activePlayer === 'A' ? 'B' : 'A';
              clearInterval(crossfadeInterval);
            }
          }
        }, fadeIntervalMs);
      }

      // Se jÃ¡ estiver tocando, inicia crossfade logo
      if(activePlayerObj.getPlayerState() === YT.PlayerState.PLAYING) {
        startFade();
      } else {
        // Se nÃ£o, espera o player tocar para comeÃ§ar crossfade
        const listener = (event) => {
          if(event.data === YT.PlayerState.PLAYING) {
            startFade();
            // Remove listener para evitar duplicaÃ§Ã£o
            if(activePlayer === 'A') playerA.removeEventListener('onStateChange', listener);
            else playerB.removeEventListener('onStateChange', listener);
          }
        };
        if(activePlayer === 'A') playerA.addEventListener('onStateChange', listener);
        else playerB.addEventListener('onStateChange', listener);
      }
    }

    // Backup: se vÃ­deo terminar sem crossfade
    function onPlayerStateChange(event) {
      if(event.data === YT.PlayerState.ENDED) {
        playNext();
      }
    }

    function playNext() {
      const nextIndex = (currentIndex + 1) % playlist.length;
      setVideo(nextIndex);
    }

    // SincronizaÃ§Ã£o
    async function syncChecker() {
      const data = await fetchSync();
      if(data && data.syncid !== syncIdAtual) {
        const idx = playlist.findIndex(v => v.id === data.syncid);
        if(idx >= 0) setVideo(idx);
      }
    }

    async function reloadPlaylist() {
      playlist = await fetchVideos();
      renderPlaylist();
    }

    async function loadApp() {
      await reloadPlaylist();
      await updateButtonState(0);
      const sync = await fetchSync();
      if(sync) {
        const idx = playlist.findIndex(v => v.id === sync.syncid);
        if(idx >= 0) setVideo(idx);
      } else if(playlist.length > 0) {
        setVideo(0);
      }
    }

    // Check botÃµes de atualizaÃ§Ã£o
    setInterval(syncChecker, 500);
    setInterval(updateSyncStatus, 500);
  </script>
</body>
</html>
